/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";

import { Context, HttpRequest } from "@azure/functions";
import {
  ApiKeyLocation,
  ApiKeyProvider,
  AxiosInstance,
  createApiClient,
} from "@microsoft/teamsfx";

import config from "../config";
import example from "../example.json";
import sqlPrompt from "../prompt";

// Define a Response interface with a status number and a body object that can contain any key-value pairs.
interface Response {
  status: number;
  body: { [key: string]: any };
}

interface Example {
  content: string;
  role: string;
}

// Define a TeamsfxContext type as an object that can contain any key-value pairs.
type TeamsfxContext = { [key: string]: any };

/**
 * This function is the entry point for the Azure Function.
 * It handles HTTP requests from the Teams client and calls the appropriate function based on the request parameters.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 * @returns {Promise<Response>} - A promise that resolves with the HTTP response.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: Response = {
    status: 200,
    body: {},
  };

  // Put an echo into response body.
  res.body.receivedHTTPRequestBody = req.body || "";

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return {
      status: 400,
      body: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Get the apiType, method, and request data from the HTTP request.
  const apiType = req.query["apiType"];
  const reqData = req.body;

  try {
    // Call the appropriate function based on the apiType.
    const result = await handleRequest(apiType, reqData);
    res.body = { ...res.body, ...result };
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error: "Failed to process request.",
      },
    };
  }

  return res;
}

/**
 * Handles the request based on the given apiType.
 *
 * @param {string} apiType - The type of api to query.
 * @param {any} reqData - The request data to use (if applicable).
 * @returns {Promise<any>} - A promise that resolves with the result of the request.
 */
async function handleRequest(apiType: string, reqData: any): Promise<any> {
  switch (apiType) {
    case "database": {
      return {
        queryResult: await queryDB(
          "SELECT Top 10 ProductID, sum(OrderQty) as SaleCount FROM [SalesLT].[SalesOrderDetail] GROUP BY ProductID"
        ),
        xKey: "ProductID",
        yKey: "SaleCount",
      };
    }
    case "aiCompletion": {
      const aiResponse = await sqlCompletion(reqData.question);
      const parsedResponse = JSON.parse(aiResponse);
      return {
        queryResult: await queryDB(parsedResponse.sql),
        sqlString: parsedResponse.sql,
        xKey: parsedResponse.xKey,
        yKey: parsedResponse.yKey,
      };
    }
    // If no matching apiType is found
    default: {
      throw new Error(`Invalid apiType (${apiType})`);
    }
  }
}

/**
 * Provides autocompletion suggestions for SQL queries.
 * @param body The SQL query to provide suggestions for.
 * @returns A list of autocompletion suggestions.
 */
async function sqlCompletion(body: string): Promise<string> {
  // Create examples for the autocompletion API
  let examples: Example[] = [];
  example.forEach((element) => {
    examples.push({
      content: element.request,
      role: "user",
    });
    examples.push({
      content: JSON.stringify(element.response),
      role: "assistant",
    });
  });

  // Create the completion request
  const completionReq = {
    messages: [
      {
        content: sqlPrompt,
        role: "system",
      },
      ...examples,
      {
        content: body,
        role: "user",
      },
    ],
  };

  // Call the autocompletion API
  const completionResp = await callOAI(completionReq);

  // Return the autocompletion suggestions
  const response = completionResp.message.content;
  return response;
}

/**
 * Calls the OpenAI API with the provided request object.
 * @param request - The request object to be sent to the OpenAI API.
 * @returns The response object from the OpenAI API.
 */
async function callOAI(request: any) {
  const authProvider = new ApiKeyProvider(
    "api-key",
    config.oaiApiKey,
    ApiKeyLocation.Header
  );
  const apiClient: AxiosInstance = createApiClient(
    config.oaiEndpoint,
    authProvider
  );
  const resp = await apiClient.post(config.chatCompletionUrl, request);
  if (resp.status !== 200) {
    throw new Error(`Failed to call OpenAI API. Status code: ${resp.status}`);
  }

  const response = resp.data.choices[0];
  return response;
}

/**
 * Executes a SQL query using the provided SQL string.
 * @param {string} sqlStr - The SQL query string to execute.
 * @returns {Promise<any>} - A Promise that resolves with the result set of the query.
 */
async function queryDB(sqlStr: string): Promise<any> {
  const sqlConfig = {
    user: config.sqlUser,
    password: config.sqlPassword,
    server: config.sqlServer,
    database: config.sqlDatabase,
    options: {
      encrypt: true,
      trustServerCertificate: true,
    },
  };
  try {
    var poolConnection = await require("mssql").connect(sqlConfig);
    var resultSet = await poolConnection.request().query(sqlStr);
    return resultSet.recordset;
  } catch (err) {
    console.error(err);
  } finally {
    // release resources
    poolConnection.close();
  }
}
